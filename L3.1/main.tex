\documentclass[a4paper,11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{mathptmx}

\usepackage[a4paper,text={160mm,220mm},centering]{geometry}

\usepackage{hyperref}
\usepackage{listings}
\usepackage{graphicx}
\usepackage[table]{xcolor}

\lstset{basicstyle={\ttfamily}}

\usepackage{todonotes}

\begin{document}
\sloppy\hbadness=9999

\thispagestyle{empty}

\unitlength=1mm
\begin{picture}(140,30)
\put(-10,30){\includegraphics[height=12mm]{../images/TIS-logo.png}}
\put(-10,11){\includegraphics[height=22mm]{../images/adacore.png}}
\put(-6,0){\includegraphics[height=12mm]{../images/logo_ocamlpro.png}}
\put(125,30){\includegraphics[height=10mm]{../images/Universite_Paris_Saclay_logo.png}}
\put(127,12){\includegraphics[height=16mm]{../images/cnrs.png}}
\put(123,0){\includegraphics[height=12mm]{../images/logo-inria-reduced.png}}
\end{picture}

\vfill

\begin{center}

{  \Huge\bfseries
  Projet Décysif --- Livrable 3.1 }

\bigskip

{ \LARGE\bfseries Memory Models for Pointer Programs: a State of the
  Art from the Point of View of Décysif Partners }


\vfill

\large January 2025

\vfill

\large
% Yannick Moy (AdaCore),
% Guillaume Cluzel (TrustInSoft),
% Matteo Manighetti (Inria \& Université Paris-Saclay),
Claude Marché (Inria \& Université Paris-Saclay)


\end{center}

\vfill

\noindent\begin{picture}(140,30)
\put(0,0){\includegraphics[width=0.3\textwidth]{../images/Logo_Bpifrance.png}}
\put(70,0){\includegraphics[width=0.3\textwidth]{../images/LOGO_RIDF_2019_COULEUR.png}}
\put(145,0){\includegraphics[width=0.1\textwidth]{../images/Logo-France-2030-rouge-bleu.png}}
\end{picture}

\noindent Le projet Décysif est financé par la Région Île-de-France et par le Gouvernement
Français dans le cadre du Plan France 2030

\clearpage

\tableofcontents
\clearpage

% \listoffigures
% \clearpage

\section{Introduction}

The term \emph{Deductive Verification} denotes the methodology for verifying
that a computer programs is conforming to a specification of its intended
behavior, with the use of techniques based of automated theorem proving. In
this context, the specification is written in some formal mathematical language,
and the conformity of the code with respect to the specification is
automatically reduced into a set of mathematical formulas than must proved
valid. When the computer programs considered are expressed in a programming
language making use of pointers to access their memory heap, the interpretation
of programs into mathematical formulas must rely on a \emph{logical description} of
such pointers and of the memory heap: the so-called \emph{memory model}.

When reasoning mathematically on pointer programs, the suitability of the memory
model is crucial. One major challenge is the potential \emph{aliasing} of memory
contents: when using pointers, the same memory cell can be denoted by
multiple ``names'', or ``access paths''. Modification of the memory content
through one of these names should be taken into account when accessing the same
memory cell via another name. More generally, \emph{blocks} of memory cells can be read
or written through such access paths, and these blocks may \emph{overlap}. The property of
non-overlapping for memory blocks is called their \emph{separation}. Separation
assumptions play an important role when reasoning about pointer
programs, an early reference publication on that subject is due to Bornat in 2000~\cite{bornat00mpc}.

A memory model cannot be described uniformly among different programming
languages. On the contrary, a specific memory model must be defined for each
programming language considered. It is even possible to consider several memory
models for different supported subsets of a given programming language, as in
the WP plug-in of the Frama-C environment for analysis of C
code~\cite{blanchard2024wp}.
%
The Décysif project gathers partners involved in the design of
verification environments for several programming languages, involving
different approaches for memory access. They develop multiple tools and each of them
contains a different approach for dealing with aliasing and separation: the tool
Why3 for WhyML programs, the SPARK environment for Ada code, the J3
analyzer for C and C++ code, and the Creusot tool for Rust code.

Generally speaking, there are numerous technical challenges related to the
design of memory models. This is not the purpose of this document to review
them. Instead we recommend to the interested reader the reading of a survey on
that purpose by Leavens \emph{et. al.}~\cite{leavens07} published in 2007.  The
purpose of this document is to summarize the different memory models
implemented in the tools of the Décysif partners, focusing on the important design
choices, and briefly compare them with each other and with other existing
approaches in the international community of deductive verification. From such a
summary, we derive and expose some future work we want to perform in the context
of the Décysif project.

TODO: Overview of the document: Section~\ref{sec:why3}, Section~\ref{sec:spark},
Section~\ref{sec:j3}, Section~\ref{sec:creusot}, Section~\ref{sec:related},
Section~\ref{sec:future}.

\section{The memory model of Why3}
\label{sec:why3}

\todo[inline]{Premier jet par Claude $\to$ relecture souhaitée par Andrei et
  Jean-Christophe}

The Why3
environment~\cite{filliatre13esop,bobot14sttt,blazy19fmtea,paskevich20isola} is
designed and developed by the Inria partner of Décysif. It is not an environment
for a particular mainstream programming language such as C or Java. Instead, it
is designed as a \emph{generic} environment for deductive verification. This
genericity comes into different aspects. First, Why3 proposes its own
programming language, called WhyML, dedicated to deductive verification, in the
sense that it is designed to ease the generation of verification conditions,
making the proof of these formulas as automatic as possible. This relies on a
second generic aspect of Why3: its ability to communicate with a large set of
provers to discharge the verification conditions~\cite{boogie11why3}. A third
generic aspect of Why3 is its suitability to be used as an intermediate language
for deductive verification: as a matter of fact, WhyML is used as an
intermediate language by the other tools mentioned below: SPARK, J3 and Creusot.

In the WhyML language, mutability of memory is supported, but to control the
difficulties coming from aliasing and separation, mutation of memory is
controlled by a dedicated powerful \emph{static} typing system. This typing
system is expressed on top of important notions of \emph{ownership} and
\emph{regions}~\cite{gondelman16reg}. Thanks to this typing system, the
potential issues with aliasing and memory separation are handled \emph{during}
the generation of VCs, so that the generated formulas do not need to take
aliasing anymore into account. Roughly speaking, the generated VCs are as simple
as if they were coming from a purely functional programming language, with no
memory mutability at all. One must understand in particular that this approach
differs fundamentally with other approaches well-known in the literature, such
as \emph{separation logic}~\cite{Tuch_KN_07} or \emph{dynamic
  frames}~\cite{Smans09}, where non-aliasing and separation properties are still
present in the logic formulas to be proved valid, which makes the work of
provers significantly more difficult. The powerful region-based mechanism of
Why3 comes at a cost though: the set of programs that one is writing in WhyML
must pass the static type checking, which means the programmer must think carefully
about how the side effects in their program must be expressed.

The research work around Why3 is still active nowadays, e.g. regarding
the design of better constructs for writing specifications, the
improvement of the ratio of proof automation, or the generation of
counterexamples when proofs
fail~\cite{dailler18jlamp,becker21fide}. In the context of Décysif,
the efforts are planned on two directions: the design of an
alternative to WhyML, and the improvement of counterexamples
generation to better suit the need of front-ends of the partners. These
are details in Section~\ref{sec:future} below.

\section{The Memory Model of SPARK}
\label{sec:spark}

\todo[inline]{Premier jet par Claude $\to$ rédaction à reprendre par AdaCore,
  Claire (qui peut déléguer!)}

Originally in the 90s, SPARK appeared as a subset of Ada, suitable to be
equipped with specifications in Z~\cite{carre90} that can be formally
verified. In 2014, AdaCore released SPARK2014~\cite{mccormick15} as a complete
re-implementation of SPARK, made compatible with Ada 2012, a version of Ada that
introduced specification contracts as part of Ada. Since that time, SPARK is
using WhyML as an intermediate language, and Why3 as a verification condition
generator.

The Ada subset supported by SPARK is highly restricted regarding to use of
pointers (called access types in Ada) and memory allocation. In essence, these
pointers are forbidden, so that no possible aliasing can take place. This high
restriction allows to translate SPARK programs into WhyML with a simple
\emph{flat} memory model, where all mutable locations are identified as WhyML
mutable variables. Such a choice made the generation of VCs simple enough to
obtain a satisfactory level of automation of proofs, and also allowed the
possibility of generation meaningfull counterexamples~\cite{dailler18jlamp}.

Yet, disallowing the use of access types in SPARK is highly restrictive. In
2020, the SPARK developers introduced some support for them. To control aliasing,
a technique inspired by the Rust borrowing policy and the Prusti tool was
designed and implemented~\cite{dross20cav,jaloyan20icfem}. An essential idea
being that technique is that each aliasing is statically known by the type
system, so that programs can continue to be translated into an aliasing-free
WhyML program. Later on, the method implemented was slightly modified to follow
the idea of \emph{prophetic encoding} introduced originally by Matsushita \emph{et
al}~\cite{matsushita20esop}.

Nowadays, the major issues with SPARK remain the need to increase the ratio of
automation of proofs, and to produce better counterexamples. The objectives for
SPARK in the Décysif project are detailed in Section~\ref{sec:future} below.

\section{The memory model of J3}
\label{sec:j3}

\todo[inline]{Premier jet par Claude $\to$ rédaction à reprendre par TrustInSoft,
  Guillaume (qui peut déléguer!)}

Since its creation in 2013, TrustInSoft develops TIS-Analyzer, an environment
for formal analysis of C and C++ source code. The central method for analyzing
code is an abstract interpretation engine, that is aimed at detecting undefined
behaviors in any kind of C programs. To complement the use of abstract
interpretation when alarms are signaled, it was decided in 2020 to design and implement
a new plug-in, called J3, to apply deductive verification techniques on such C
and C++ code.

The initial design of J3 included important decision regarding the supported
subset of C. In essence, it was decided that any kind of code should be
supported. That includes low-level C code, making using of complex low-level,
architecture-dependent bit-wise manipulation, but also arbitrary use of
pointers, and conversion (cast) of such pointers. Memory allocation and freeing
must be supported too, so as any kind of aliasing and memory overlap. To reach
such an ambiguous goal, but not starting everything from scratch, it was decided
to reuse some existing memory model, namely it was decided to use CompCert
V2~\cite{leroy12rr} memory model, already formalized in Coq, and the basis of
the C semantics on which the verified C compiler CompCert operates.

The formalization of the memory model for J3 is done using WhyML, it makes heavy
use of bit-vectors~\cite{fumex16nfm}. It explicitly defines the notions of memory
blocks and permissions, so that at the end, generated verification conditions
for a C code contains explicit pointers, predicates expressing separation (or
not separation) and other memory-related concepts. A consequence of this design
is that in its current state, the proofs done using J3 suffer from a poor ratio
of automation. It is one of the objective in Décysif to increase this ratio.

Another important design choice for J3 was the will to obtain a counterexample
when a proof fails. In its current state, J3 is able to produce such
counterexamples in some cases, but overall the methodology needs significant
improvement. Even more, it is a central goal in Décysif to be able to turn such
a counterexample into an \emph{exploit}, that is an explicit test case that
exposes a vulnerability regarding safety or security.

The Décysif objectives for J3 are detailed below in Section~\ref{sec:future}.

\paragraph{positioning}

J3 is far from being the only tool for deductive verification of C
code. Historically, Frama-C/WP~\cite{blanchard2024wp} is a deductive
verification plugin for Frama-C, the environment from which TIS-Analyzer was
derived. WP design was guided by different choices, in particular it does not
attempt to support any kind of memory aliasing. On the contrary, it provides a
set of variants of memory model where separation is partially or even totally
assumed. Also, it wasn't designed with the need of counterexample in mind, and
only very recently has this as an experimental new feature. Comparison between
J3 and WP on that matter will be interesting to investigate in the future.

Jessie is another historic deductive verification plugin for Frama-C, designed
on top of the predecessor of Why3. It is not maintained anymore. J3 design
inherits in part from Jessie. It is in particular planned to resurrect in J3 a
static separation analysis similar to the one of
Jessie~\cite{hubert2008these,hubert07hav}

VCC~\cite{dahlweid09icse} was historically another tool for deductive
verification of C, inspired by Spec\# ownership (see Section~\ref{sec:related}
below). Not any kind of memory aliasing was supported. It is not maintained
anymore.
%
VST~\cite{appel11esop} is an environment built on top of CompCert and a Coq
formalization of separation logic. To perform a proof of some C code, it is
mandatory to use the Coq system, thus having a low level of automation. An
advantage though is that the underlying memory model is low-level and precise.
%
Verifast~\cite{jacobs11nfm} is a tool for deductive verification of C (and Java)
code. It relies on separation logic and/or dynamic frames. To perform proofs,
the code must be annotated by the user to explicit the reasoning regarding
opening or closing definitions of memory-related representation predicates.
%
Isabelle/C~\cite{tuong19fide} is an environment for reasoning on C code on top
of Isabelle/HOL and its layer AutoCorres for imperative programs. To perform
proofs it is mandatory to use the Isabelle system interactively.
%
Generally speaking, the tools above are not designed to produce exploits in case of
proof failure, or even counterexamples.

Notice finally that J3 has the ambition to be applied on C++ code, which is
hardly supported by any other tool.

\section{The memory model of Creusot}
\label{sec:creusot}

  \todo{Premier jet par Claude, rédaction à reprendre par l'équipe Creusot, Jacques-Henri ?}

Relies on Rust's borrow checker to propose a translation to Why3. mutable
borrows are translated to pairs of current value and future final value
(prophecy).\cite{denis23phd,denis22icfem,matsushita22pldi}.

\paragraph{positioning}

Prusti~\cite{astrauskas19oopsla}, aeneas~\cite{ho22icfp}


\section{Comparison with Tools for Other Languages}
\label{sec:related}

Java, ESC-Java, JML, data groups~\cite{breunesse03ftfjp}, universes~\cite{Dietl05jot}

Spec\# ~\cite{BarnettLS04},

Separation Logic appeared in 2002, but hardly any automated tool first

dynamic frames, Dafny~\cite{leino14fide}

Iris~\cite{iris17}

Ynot in Coq, CFML~\cite{chargueraud08icfp}, gospel~\cite{gospelfm19}, Cameleer~\cite{DBLP:conf/cav/PereiraR20}

VST, separation logic upon CompCert memory model (already above)

Isabelle/?   (Isabelle/C already above)

Viper, Prusti, Vercors

Scala -> Stainless, EPFL [ijcar 2024 ?]

\section{Future Work within Décysif}
\label{sec:future}



\begin{description}
\item[Flexible Abstraction Barriers]

  New intermediate language in Why3, called Coma, continuation-based. On going thesis of
  Paul Patault.

\item[From Counterexamples to Exploits]

  Better support for counterexamples, needs to makes memory models
  more concrete, more ``executable-like'', to obtain directly test
  case in frontends to be replayed as exploits.

\item[Future Work in SPARK]
  \todo{Rédacteur Souhaité: AdaCore, Claire ?}

  Increase level of automation ?

  Turning counterexamples into true ``exploits'', that is concrete test cases exposed vulnerabilities ?

  Add prophecies in the Specification language of SPARK ?

\item[J3]

  Separation analysis for its memory model. static analysis
of separation similar to the old plugin
Jessie~\cite{hubert2008these,hubert07hav}.

  Executability for exploit

\item[Extensions of Creusot]

  Support for concurrency in Creusot, Support for ghost aliasing, on-going
  thesis of Arnaud Golfouse.

\item[CEs in Creusot]

\end{description}

\bibliographystyle{plainurl}
\bibliography{abbrevs,demons,demons2,demons3,team,crossrefs}
%\bibliography{generated,extra}

%\clearpage


\end{document}

% Local Variables:
% mode: latex
% TeX-master: t
% TeX-PDF-mode: t
% eval: (flyspell-mode 1)
% ispell-local-dictionary: "american"
% fill-column: 80
% End:

% LocalWords:  Décysif genericity
