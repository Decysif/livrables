@comment{{This file has been generated by bib2bib 1.99}}

@comment{{Command line: bib2bib --rename hal url -ob generated.bib temp.bib}}

@comment{{This file has been generated by bib2bib 1.99}}

@comment{{Command line: bib2bib -c '$key="becker21fide" or $key="paskevich20isola" or $key="BarnettLS04" or $key="denis23phd" or $key="hubert2008these" or $key="dross20cav" or $key="leroy12rr" or $key="chargueraud08icfp" or $key="matsushita22pldi" or $key="hubert07hav" or $key="blanchard2024wp" or $key="filliatre13esop" or $key="leavens07" or $key="jaloyan20icfem" or $key="bobot14sttt" or $key="Dietl05jot" or $key="dailler18jlamp" or $key="blazy19fmtea" or $key="herms13phd" or $key="fumex16nfm" or $key="denis22icfem" or $key="gondelman16reg" or $key="ho22icfp" or $key="gospelfm19" or $key="breunesse03ftfjp" or $key="bornat00mpc" or $key="astrauskas19oopsla" or 1=2' /home/cmarche/biblio/abbrevs.bib /home/cmarche/biblio/demons.bib /home/cmarche/biblio/demons2.bib /home/cmarche/biblio/demons3.bib /home/cmarche/biblio/team.bib /home/cmarche/biblio/crossrefs.bib}}

@string{eptcs = {Electronic Proceedings in Theoretical Computer Science}}

@string{jot = {Journal of Object Technology}}

@string{sv = {Springer}}

@string{rr = {Research Report}}

@string{ups = {Universit{\'e} Paris-Sud}}

@string{thesedoctorat = {Th{\`e}se de Doctorat}}

@string{lncs = {Lecture Notes in Computer Science}}

@string{ups = {Universit{\'e} Paris-Sud}}

@inproceedings{BarnettLS04,
  author = {Mike Barnett and K. Rustan M. Leino   and Wolfram Schulte},
  title = {{The Spec\# Programming System: An Overview}},
  booktitle = {Construction and Analysis of Safe, Secure, and Interoperable Smart Devices (CASSIS'04)},
  pages = {49--69},
  year = {2004},
  volume = {3362},
  publisher = sv,
  series = lncs
}

@inproceedings{bornat00mpc,
  author = {Richard Bornat},
  title = {Proving Pointer Programs in {H}oare Logic},
  booktitle = {Mathematics of Program Construction},
  pages = {102--126},
  year = {2000}
}

@inproceedings{breunesse03ftfjp,
  author = {C.-B. Breunesse and E. Poll},
  title = {Verifying {JML} Specifications with Model Fields},
  booktitle = {Formal Techniques for Java-like Programs (FTFJP'03)},
  year = 2003
}

@article{leavens07,
  author = {Leavens, Gary T. and Leino, K. Rustan M. and M\"uller, Peter},
  title = {Specification and verification challenges for sequential object-oriented programs},
  journal = {Formal Aspects of Computing},
  pages = {159--189},
  year = 2007
}

@article{Dietl05jot,
  author = {Werner Dietl and Peter M\"uller},
  title = {Universes: Lightweight Ownership for {JML}},
  journal = jot,
  year = 2005,
  volume = 4,
  number = 8,
  pages = {5-32}
}

@inproceedings{chargueraud08icfp,
  author = {Arthur Chargu\'eraud and Fran\c{c}ois Pottier},
  title = {Functional Translation of a Calculus of Capabilities},
  booktitle = {{ACM} {SIGPLAN} International
                 Conference on Functional Programming (ICFP)},
  month = sep,
  year = {2008},
  pages = {213--224},
  url = {http://gallium.inria.fr/~fpottier/publis/chargueraud-pottier-capabilities.pdf},
  doi = {10.1145/1411204.1411235},
  abstract = {Reasoning about imperative programs requires the
                 ability to track aliasing and ownership properties. We
                 present a type system that provides this ability, by
                 using regions, capabilities, and singleton types. It is
                 designed for a high-level calculus with higher-order
                 functions, algebraic data structures, and references
                 (mutable memory cells). The type system has
                 polymorphism, yet does not require a value restriction,
                 because capabilities act as explicit store typings.\par
                 We exhibit a type-directed, type-preserving, and
                 meaning-preserving translation of this imperative
                 calculus into a pure calculus. Like the monadic
                 translation, this is a store-passing translation. Here,
                 however, the store is partitioned into multiple
                 fragments, which are threaded through a computation
                 only if they are relevant to it. Furthermore, the
                 decomposition of the store into fragments can evolve
                 dynamically to reflect ownership transfers.\par The
                 translation offers deep insight about the inner
                 workings and soundness of the type system. If coupled
                 with a semantic model of its target calculus, it leads
                 to a semantic model of its imperative source calculus.
                 Furthermore, it provides a foundation for our long-term
                 objective of designing a system for specifying and
                 certifying imperative programs with dynamic memory
                 allocation.}
}

@inproceedings{dross20cav,
  author = {Claire Dross and Johannes Kanig},
  title = {Recursive Data Structures in SPARK},
  booktitle = {Computer Aided Verification},
  year = 2020
}

@inproceedings{blazy19fmtea,
  title = {Teaching Deductive Verification in {Why3} to Undergraduate Students},
  author = {Blazy, Sandrine},
  url = {https://hal.inria.fr/hal-02362306},
  booktitle = {{FM Tea (Formal Methods Teaching)}},
  address = {Porto, Portugal},
  pages = {52--66},
  doi = {10.1007/978-3-030-32441-4_4},
  year = 2019
}

@article{astrauskas19oopsla,
  author = {Vytautas Astrauskas and
               Peter M{\"{u}}ller and
               Federico Poli and
               Alexander J. Summers},
  title = {Leveraging {Rust} types for modular specification and verification},
  journal = {Proc. {ACM} Program. Lang.},
  volume = 3,
  number = {{OOPSLA}},
  pages = {147:1--147:30},
  year = 2019,
  doi = {10.1145/3360573}
}

@techreport{leroy12rr,
  title = {The {CompCert} Memory Model, Version 2},
  author = {Leroy, Xavier and Appel, Andrew W. and Blazy, Sandrine and Stewart, Gordon},
  url = {https://hal.inria.fr/hal-00703441},
  type = {Research Report},
  number = {RR-7987},
  institution = {INRIA},
  year = 2012
}

@article{ho22icfp,
  title = {Aeneas: {Rust} verification by functional translation},
  author = {Ho, Son and Protzenko, Jonathan},
  url = {https://hal.science/hal-03931572},
  journal = {Proceedings of the ACM on Programming Languages},
  publisher = {ACM},
  volume = 6,
  number = {ICFP},
  pages = {711--741},
  year = 2022,
  doi = {10.1145/3547647}
}

@inbook{blanchard2024wp,
  author = {Blanchard, Allan and Bobot, Fran{\c{c}}ois and Baudin, Patrick and Correnson, Lo{\"i}c},
  title = {Formally Verifying that a Program Does What It Should: The {Wp} Plug-in},
  booktitle = {Guide to Software Verification with {Frama-C}: Core Components, Usages, and Applications},
  year = {2024},
  publisher = {Springer International Publishing},
  pages = {187--261},
  doi = {10.1007/978-3-031-55608-1_4}
}

@inproceedings{hubert07hav,
  author = {Thierry Hubert and Claude March\'e},
  title = {Separation Analysis for Deductive Verification},
  booktitle = {Heap Analysis and Verification (HAV'07)},
  year = 2007,
  address = {Braga, Portugal},
  month = mar,
  topics = {team, lri},
  url = {https://hal.inria.fr/hal-03630177},
  type_publi = {icolcomlec},
  type_digiteo = {conf_autre},
  pages = {81--93},
  x-equipes = {demons PROVAL},
  x-type = {article},
  x-support = {actes_aux},
  x-cle-support = {HAV}
}

@phdthesis{hubert2008these,
  author = {Thierry Hubert},
  title = {Analyse Statique et preuve de Programmes Industriels Critiques},
  school = ups,
  year = 2008,
  type = thesedoctorat,
  month = jun,
  topics = {team},
  x-equipes = {demons PROVAL},
  x-type = {these},
  x-support = {rapport},
  url = {http://www.lri.fr/~marche/hubert08these.pdf}
}

@inproceedings{filliatre13esop,
  author = {Jean-Christophe Filli\^atre and Andrei Paskevich},
  title = {Why3 --- Where Programs Meet Provers},
  booktitle = {Proceedings of the 22nd European Symposium on Programming},
  month = mar,
  year = 2013,
  volume = {7792},
  series = lncs,
  publisher = sv,
  editor = {Matthias Felleisen and Philippa Gardner},
  pages = {125--128},
  url = {http://hal.inria.fr/hal-00789533},
  topics = {team,lri},
  keywords = {Why3},
  type_publi = {icolcomlec},
  x-equipes = {demons PROVAL},
  x-type = {article},
  x-support = {actes},
  x-cle-support = {ESOP},
  x-editorial-board = {yes},
  x-international-audience = {yes}
}

@phdthesis{herms13phd,
  author = {Paolo Herms},
  title = {Certification of a Tool Chain for Deductive Program Verification},
  school = ups,
  type = thesedoctorat,
  url = {http://tel.archives-ouvertes.fr/tel-00789543},
  note = {\url{http://tel.archives-ouvertes.fr/tel-00789543}},
  x-equipes = {demons PROVAL},
  x-support = {rapport},
  x-type = {these},
  topics = {team},
  year = 2013,
  month = jan
}

@article{bobot14sttt,
  topics = {team},
  doi = {10.1007/s10009-014-0314-5},
  hal_id = {hal-00967132},
  url = {http://hal.inria.fr/hal-00967132/en},
  author = {Fran\c{c}ois Bobot and Jean-Christophe Filli\^atre and Claude March\'e and Andrei Paskevich},
  title = {Let's Verify This with {Why3}},
  journal = {International Journal on Software Tools for Technology Transfer (STTT)},
  volume = 17,
  number = 6,
  pages = {709--727},
  year = 2015,
  note = {See also \url{http://toccata.gitlabpages.inria.fr/toccata/gallery/fm2012comp.en.html}},
  publisher = {Springer Berlin / Heidelberg},
  x-type = {article},
  x-support = {revue},
  x-cle-support = {STTT},
  x-international-audience = {yes},
  x-editorial-board = {yes}
}

@inproceedings{fumex16nfm,
  topics = {team},
  author = {Fumex, Cl\'ement and Dross, Claire and Gerlach, Jens and March\'e, Claude},
  title = {Specification and Proof of High-Level Functional Properties of Bit-Level Programs},
  pages = {291--306},
  crossref = {nfm16},
  url = {https://hal.inria.fr/hal-01314876}
}

@techreport{gondelman16reg,
  topics = {team},
  author = {Jean-Christophe Filli\^atre and L\'eon
            Gondelman and Andrei Paskevich},
  title = {A Pragmatic Type System for Deductive Verification},
  type = rr,
  institution = {Universit\'e Paris Sud},
  year = 2016,
  abstract = { In the context of deductive verication, it is customary
                  today to handle programs with pointers using either
                  separation logic, dynamic frames, or explicit memory
                  models. Yet we can observe that in numerous
                  programs, a large amount of code ts within the scope
                  of Hoare logic, provided we can statically control
                  aliasing. When this is the case, the code
                  correctness can be reduced to simpler verication
                  conditions which do not require any explicit memory
                  model. This makes verication conditions more
                  amenable both to automated theorem proving and to
                  manual inspection and debugging. In this paper, we
                  devise a method of such static aliasing control for
                  a programming language featuring nested data
                  structures with mutable components. Our solution is
                  based on a type system with singleton regions and
                  eects, which we prove to be sound.},
  url = {https://hal.archives-ouvertes.fr/hal-01256434v3},
  note = {\url{https://hal.archives-ouvertes.fr/hal-01256434v3}}
}

@article{dailler18jlamp,
  topics = {team},
  title = {Instrumenting a Weakest Precondition Calculus for Counterexample Generation},
  author = {Dailler, Sylvain and Hauzar, David and March{\'e}, Claude and Moy, Yannick},
  url = {https://hal.inria.fr/hal-01802488},
  journal = {Journal of Logical and Algebraic Methods in Programming},
  publisher = {Elsevier},
  volume = 99,
  pages = {97--113},
  year = 2018,
  doi = {10.1016/j.jlamp.2018.05.003},
  keywords = {Deductive Program Verification ; Weakest Precondition Calculus ; Satisfiability Modulo Theories ; Counterexamples}
}

@inproceedings{gospelfm19,
  topics = {team},
  crossref = {fm19},
  author = {Arthur Chargu\'eraud and Jean-Christophe Filli\^atre and Cl\'audio Belo Louren\c{c}o and M\'ario Pereira},
  title = {{GOSPEL} --- Providing {OCaml} with a Formal Specification Language},
  url = {https://hal.inria.fr/hal-02157484}
}

@inproceedings{paskevich20isola,
  author = {Jean-Christophe Filli\^atre and Andrei Paskevich},
  title = {Abstraction and Genericity in {Why3}},
  booktitle = {9th International Symposium On Leveraging Applications of Formal Methods, Verification and Validation (ISoLA)},
  month = oct,
  year = 2020,
  publisher = sv,
  series = lncs,
  volume = 12476,
  pages = {122--142},
  editor = {Tiziana Margaria and Bernhard Steffen},
  address = {Rhodes, Greece},
  topics = {team},
  note = {See also \url{https://usr.lmf.cnrs.fr/~jcf/isola-2020/}},
  url = {https://hal.inria.fr/hal-02696246}
}

@inproceedings{becker21fide,
  topics = {team},
  title = {Explaining Counterexamples with Giant-Step Assertion Checking},
  author = {Becker, Benedikt and Belo Louren\c{c}o, Cl{\'a}udio and March{\'e}, Claude},
  url = {https://hal.inria.fr/hal-03217393},
  booktitle = {6th Workshop on Formal Integrated Development Environments (F-IDE 2021)},
  editor = {Creissac Campos, Jos{\'e} and Paskevich, Andrei},
  series = eptcs,
  doi = {10.4204/EPTCS.338.10},
  year = 2021,
  month = may
}

@inproceedings{jaloyan20icfem,
  topics = {team},
  title = {Verification of Programs with Pointers in {SPARK}},
  author = {Jaloyan, Georges-Axel and Dross, Claire and Maalej, Maroua and Moy, Yannick and Paskevich, Andrei},
  url = {https://hal.inria.fr/hal-03094566},
  booktitle = {Formal Methods and Software Engineering (ICFEM)},
  pages = {55--72},
  year = 2020,
  doi = {10.1007/978-3-030-63406-3\_4}
}

@inproceedings{denis22icfem,
  topics = {team},
  title = {{Creusot}: a Foundry for the Deductive Verication of {Rust} Programs},
  author = {Denis, Xavier and Jourdan, Jacques-Henri and March{\'e}, Claude},
  url = {https://hal.inria.fr/hal-03737878},
  booktitle = {International Conference on Formal Engineering Methods - ICFEM},
  address = {Madrid, Spain},
  publisher = sv,
  series = lncs,
  year = 2022,
  keywords = {Rust programming language ; Deductive program verification ; Aliasing and Ownership ; Prophecies ; Traits}
}

@inproceedings{matsushita22pldi,
  topics = {team},
  title = {{RustHornBelt}: a semantic foundation for functional verification of {Rust} programs with unsafe code},
  author = {Matsushita, Yusuke and Denis, Xavier and Jourdan, Jacques-Henri and Dreyer, Derek},
  url = {https://hal.inria.fr/hal-03777103},
  booktitle = {International Conference on Programming Language Design and Implementation},
  publisher = {ACM},
  pages = {841--856},
  year = 2022,
  doi = {10.1145/3519939.3523704}
}

@phdthesis{denis23phd,
  topics = {team},
  url = {https://hal.science/tel-04517581},
  author = {Denis, Xavier},
  title = {Deductive Verification of Rust Programs},
  school = {Universit\'e Paris-Saclay},
  year = 2023,
  type = {PhD thesis}
}

@proceedings{nfm16,
  booktitle = {8th NASA Formal Methods Symposium},
  address = {Minneapolis, MN, USA},
  audience = {internationale},
  year = 2016,
  month = jun,
  editor = {Rayadurgam, Sanjai and Tkachuk, Oksana},
  series = {Lecture Notes in Computer Science},
  volume = {9690},
  publisher = sv
}

@proceedings{fm19,
  title = {FM 2019 23rd International Symposium on Formal Methods},
  booktitle = {FM 2019 23rd International Symposium on Formal Methods},
  month = oct,
  year = 2019,
  address = {Porto, Portugal},
  editor = {Annabelle McIver and Maurice ter Beek}
}

